.TH "QwtPlotCurve" 3 "Tue Nov 20 2012" "Version 5.2.3" "Qwt User's Guide" \" -*- nroff -*-
.ad l
.nh
.SH NAME
QwtPlotCurve \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <qwt_plot_curve\&.h>\fP
.PP
Inherits \fBQwtPlotItem\fP\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBCurveAttribute\fP { \fBInverted\fP =  1, \fBFitted\fP =  2 }"
.br
.ti -1c
.RI "enum \fBCurveStyle\fP { \fBNoCurve\fP, \fBLines\fP, \fBSticks\fP, \fBSteps\fP, \fBDots\fP, \fBUserCurve\fP =  100 }"
.br
.ti -1c
.RI "enum \fBCurveType\fP { \fBYfx\fP, \fBXfy\fP }"
.br
.ti -1c
.RI "enum \fBPaintAttribute\fP { \fBPaintFiltered\fP =  1, \fBClipPolygons\fP =  2 }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBQwtPlotCurve\fP ()"
.br
.ti -1c
.RI "\fBQwtPlotCurve\fP (const \fBQwtText\fP &\fBtitle\fP)"
.br
.ti -1c
.RI "\fBQwtPlotCurve\fP (const QString &\fBtitle\fP)"
.br
.ti -1c
.RI "virtual \fB~QwtPlotCurve\fP ()"
.br
.ti -1c
.RI "double \fBbaseline\fP () const "
.br
.ti -1c
.RI "virtual QwtDoubleRect \fBboundingRect\fP () const "
.br
.ti -1c
.RI "const QBrush & \fBbrush\fP () const "
.br
.ti -1c
.RI "int \fBclosestPoint\fP (const QPoint &pos, double *dist=NULL) const "
.br
.ti -1c
.RI "\fBQwtCurveFitter\fP * \fBcurveFitter\fP () const "
.br
.ti -1c
.RI "\fBCurveType\fP \fBcurveType\fP () const "
.br
.ti -1c
.RI "\fBQwtData\fP & \fBdata\fP ()"
.br
.ti -1c
.RI "const \fBQwtData\fP & \fBdata\fP () const "
.br
.ti -1c
.RI "int \fBdataSize\fP () const "
.br
.ti -1c
.RI "virtual void \fBdraw\fP (QPainter *p, const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, const QRect &) const "
.br
.ti -1c
.RI "virtual void \fBdraw\fP (QPainter *p, const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, int from, int to) const "
.br
.ti -1c
.RI "void \fBdraw\fP (int from, int to) const "
.br
.ti -1c
.RI "double \fBmaxXValue\fP () const "
.br
.ti -1c
.RI "double \fBmaxYValue\fP () const "
.br
.ti -1c
.RI "double \fBminXValue\fP () const "
.br
.ti -1c
.RI "double \fBminYValue\fP () const "
.br
.ti -1c
.RI "const QPen & \fBpen\fP () const "
.br
.ti -1c
.RI "virtual int \fBrtti\fP () const "
.br
.ti -1c
.RI "void \fBsetBaseline\fP (double ref)"
.br
.ti -1c
.RI "void \fBsetBrush\fP (const QBrush &)"
.br
.ti -1c
.RI "void \fBsetCurveAttribute\fP (\fBCurveAttribute\fP, bool on=true)"
.br
.ti -1c
.RI "void \fBsetCurveFitter\fP (\fBQwtCurveFitter\fP *)"
.br
.ti -1c
.RI "void \fBsetCurveType\fP (\fBCurveType\fP)"
.br
.ti -1c
.RI "void \fBsetData\fP (const double *xData, const double *yData, int size)"
.br
.ti -1c
.RI "void \fBsetData\fP (const QwtArray< double > &xData, const QwtArray< double > &yData)"
.br
.ti -1c
.RI "void \fBsetData\fP (const QPolygonF &\fBdata\fP)"
.br
.ti -1c
.RI "void \fBsetData\fP (const \fBQwtData\fP &\fBdata\fP)"
.br
.ti -1c
.RI "void \fBsetPaintAttribute\fP (\fBPaintAttribute\fP, bool on=true)"
.br
.ti -1c
.RI "void \fBsetPen\fP (const QPen &)"
.br
.ti -1c
.RI "void \fBsetRawData\fP (const double *\fBx\fP, const double *\fBy\fP, int size)"
.br
.ti -1c
.RI "void \fBsetStyle\fP (\fBCurveStyle\fP \fBstyle\fP)"
.br
.ti -1c
.RI "void \fBsetSymbol\fP (const \fBQwtSymbol\fP &s)"
.br
.ti -1c
.RI "\fBCurveStyle\fP \fBstyle\fP () const "
.br
.ti -1c
.RI "const \fBQwtSymbol\fP & \fBsymbol\fP () const "
.br
.ti -1c
.RI "bool \fBtestCurveAttribute\fP (\fBCurveAttribute\fP) const "
.br
.ti -1c
.RI "bool \fBtestPaintAttribute\fP (\fBPaintAttribute\fP) const "
.br
.ti -1c
.RI "virtual void \fBupdateLegend\fP (\fBQwtLegend\fP *) const "
.br
.ti -1c
.RI "double \fBx\fP (int i) const "
.br
.ti -1c
.RI "double \fBy\fP (int i) const "
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBclosePolyline\fP (const \fBQwtScaleMap\fP &, const \fBQwtScaleMap\fP &, QwtPolygon &) const "
.br
.ti -1c
.RI "virtual void \fBdrawCurve\fP (QPainter *p, int \fBstyle\fP, const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, int from, int to) const "
.br
.ti -1c
.RI "void \fBdrawDots\fP (QPainter *p, const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, int from, int to) const "
.br
.ti -1c
.RI "void \fBdrawLines\fP (QPainter *p, const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, int from, int to) const "
.br
.ti -1c
.RI "void \fBdrawSteps\fP (QPainter *p, const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, int from, int to) const "
.br
.ti -1c
.RI "void \fBdrawSticks\fP (QPainter *p, const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, int from, int to) const "
.br
.ti -1c
.RI "virtual void \fBdrawSymbols\fP (QPainter *p, const \fBQwtSymbol\fP &, const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, int from, int to) const "
.br
.ti -1c
.RI "void \fBfillCurve\fP (QPainter *, const \fBQwtScaleMap\fP &, const \fBQwtScaleMap\fP &, QwtPolygon &) const "
.br
.ti -1c
.RI "void \fBinit\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 
A plot item, that represents a series of points\&. 

A curve is the representation of a series of points in the x-y plane\&. It supports different display styles, interpolation ( f\&.e\&. spline ) and symbols\&.
.PP
\fBUsage\fP
.RS 4

.IP "\fBa) Assign curve properties \fP" 1c
When a curve is created, it is configured to draw black solid lines with in Lines style and no symbols\&. You can change this by calling \fBsetPen()\fP, \fBsetStyle()\fP and \fBsetSymbol()\fP\&. 
.IP "\fBb) Connect/Assign data\&. \fP" 1c
\fBQwtPlotCurve\fP gets its points using a \fBQwtData\fP object offering a bridge to the real storage of the points ( like QAbstractItemModel )\&. There are several convenience classes derived from \fBQwtData\fP, that also store the points inside ( like QStandardItemModel )\&. \fBQwtPlotCurve\fP also offers a couple of variations of \fBsetData()\fP, that build \fBQwtData\fP objects from arrays internally\&. 
.IP "\fBc) Attach the curve to a plot \fP" 1c
See \fBQwtPlotItem::attach()\fP 
.PP
.RE
.PP
\fBExample:\fP
.RS 4
see examples/bode
.RE
.PP
\fBSee also:\fP
.RS 4
\fBQwtPlot\fP, \fBQwtData\fP, \fBQwtSymbol\fP, \fBQwtScaleMap\fP 
.RE
.PP

.SH "Member Enumeration Documentation"
.PP 
.SS "enum \fBQwtPlotCurve::CurveAttribute\fP"
Attribute for drawing the curve
.PP
.IP "\(bu" 2
Fitted ( in combination with the Lines \fBQwtPlotCurve::CurveStyle\fP only )
.br
 A \fBQwtCurveFitter\fP tries to interpolate/smooth the curve, before it is painted\&. Note that curve fitting requires temorary memory for calculating coefficients and additional points\&. If painting in Fitted mode is slow it might be better to fit the points, before they are passed to \fBQwtPlotCurve\fP\&.
.IP "\(bu" 2
Inverted
.br
 For Steps only\&. Draws a step function from the right to the left\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetCurveAttribute()\fP, \fBtestCurveAttribute()\fP, \fBcurveFitter()\fP 
.RE
.PP

.PP

.SS "enum \fBQwtPlotCurve::CurveStyle\fP"
Curve styles\&.
.PP
.IP "\(bu" 2
NoCurve
.br
 Don't draw a curve\&. Note: This doesn't affect the symbols\&.
.IP "\(bu" 2
Lines
.br
 Connect the points with straight lines\&. The lines might be interpolated depending on the 'Fitted' attribute\&. Curve fitting can be configured using \fBsetCurveFitter()\fP\&.
.IP "\(bu" 2
Sticks
.br
 Draw vertical(Yfx) or horizontal(Xfy) sticks from a baseline which is defined by \fBsetBaseline()\fP\&.
.IP "\(bu" 2
Steps
.br
 Connect the points with a step function\&. The step function is drawn from the left to the right or vice versa, depending on the 'Inverted' attribute\&.
.IP "\(bu" 2
Dots
.br
 Draw dots at the locations of the data points\&. Note: This is different from a dotted line (see \fBsetPen()\fP), and faster as a curve in NoStyle style and a symbol painting a point\&.
.IP "\(bu" 2
UserCurve
.br
 Styles >= UserCurve are reserved for derived classes of \fBQwtPlotCurve\fP that overload \fBdrawCurve()\fP with additional application specific curve types\&.
.PP
.PP
\fBSee also:\fP
.RS 4
\fBsetStyle()\fP, \fBstyle()\fP 
.RE
.PP

.SS "enum \fBQwtPlotCurve::CurveType\fP"
Curve type\&.
.PP
.IP "\(bu" 2
Yfx
.br
 Draws y as a function of x (the default)\&. The baseline is interpreted as a horizontal line with y = \fBbaseline()\fP\&.
.IP "\(bu" 2
Xfy
.br
 Draws x as a function of y\&. The baseline is interpreted as a vertical line with x = \fBbaseline()\fP\&.
.PP
.PP
The baseline is used for aligning the sticks, or filling the curve with a brush\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetCurveType()\fP, \fBcurveType()\fP, \fBbaseline()\fP \fBbrush()\fP 
.RE
.PP

.SS "enum \fBQwtPlotCurve::PaintAttribute\fP"
Attributes to modify the drawing algorithm\&.
.PP
.IP "\(bu" 2
PaintFiltered
.br
 Tries to reduce the data that has to be painted, by sorting out duplicates, or paintings outside the visible area\&. Might have a notable impact on curves with many close points\&. Only a couple of very basic filtering algos are implemented\&.
.IP "\(bu" 2
ClipPolygons
.br
 Clip polygons before painting them\&. In situations, where points are far outside the visible area (f\&.e when zooming deep) this might be a substantial improvement for the painting performance ( especially on Windows )\&.
.PP
.PP
The default is, that no paint attributes are enabled\&.
.PP
\fBSee also:\fP
.RS 4
\fBsetPaintAttribute()\fP, \fBtestPaintAttribute()\fP 
.RE
.PP

.SH "Constructor & Destructor Documentation"
.PP 
.SS "QwtPlotCurve::QwtPlotCurve (const \fBQwtText\fP &title)\fC [explicit]\fP"
Constructor 
.PP
\fBParameters:\fP
.RS 4
\fItitle\fP Title of the curve 
.RE
.PP

.SS "QwtPlotCurve::QwtPlotCurve (const QString &title)\fC [explicit]\fP"
Constructor 
.PP
\fBParameters:\fP
.RS 4
\fItitle\fP Title of the curve 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "double QwtPlotCurve::baseline () const"
Return the value of the baseline 
.PP
\fBSee also:\fP
.RS 4
\fBsetBaseline()\fP 
.RE
.PP

.SS "QwtDoubleRect QwtPlotCurve::boundingRect () const\fC [virtual]\fP"
Returns the bounding rectangle of the curve data\&. If there is no bounding rect, like for empty data the rectangle is invalid\&. 
.PP
\fBSee also:\fP
.RS 4
\fBQwtData::boundingRect()\fP, QwtDoubleRect::isValid() 
.RE
.PP

.PP
Reimplemented from \fBQwtPlotItem\fP\&.
.SS "const QBrush & QwtPlotCurve::brush () const"

.PP
Return the brush used to fill the area between lines and the baseline\&. \fBSee also:\fP
.RS 4
\fBsetBrush()\fP, \fBsetBaseline()\fP, \fBbaseline()\fP 
.RE
.PP

.SS "void QwtPlotCurve::closePolyline (const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, QwtPolygon &pa) const\fC [protected]\fP"

.PP
Complete a polygon to be a closed polygon including the area between the original polygon and the baseline\&. \fBParameters:\fP
.RS 4
\fIxMap\fP X map 
.br
\fIyMap\fP Y map 
.br
\fIpa\fP Polygon to be completed 
.RE
.PP

.SS "int QwtPlotCurve::closestPoint (const QPoint &pos, double *dist = \fCNULL\fP) const"
Find the closest curve point for a specific position
.PP
\fBParameters:\fP
.RS 4
\fIpos\fP Position, where to look for the closest curve point 
.br
\fIdist\fP If dist != NULL, \fBclosestPoint()\fP returns the distance between the position and the clostest curve point 
.RE
.PP
\fBReturns:\fP
.RS 4
Index of the closest curve point, or -1 if none can be found ( f\&.e when the curve has no points ) 
.RE
.PP
\fBNote:\fP
.RS 4
\fBclosestPoint()\fP implements a dumb algorithm, that iterates over all points 
.RE
.PP

.SS "\fBQwtCurveFitter\fP * QwtPlotCurve::curveFitter () const"
Get the curve fitter\&. If curve fitting is disabled NULL is returned\&. 
.PP
\fBReturns:\fP
.RS 4
Curve fitter 
.RE
.PP

.SS "\fBQwtPlotCurve::CurveType\fP QwtPlotCurve::curveType () const"
Return the curve type 
.PP
\fBSee also:\fP
.RS 4
\fBCurveType\fP, \fBsetCurveType()\fP 
.RE
.PP

.SS "\fBQwtData\fP & QwtPlotCurve::data ()\fC [inline]\fP"
\fBReturns:\fP
.RS 4
the the curve data 
.RE
.PP

.SS "const \fBQwtData\fP & QwtPlotCurve::data () const\fC [inline]\fP"
\fBReturns:\fP
.RS 4
the the curve data 
.RE
.PP

.SS "int QwtPlotCurve::dataSize () const"
Return the size of the data arrays 
.PP
\fBSee also:\fP
.RS 4
\fBsetData()\fP 
.RE
.PP

.SS "void QwtPlotCurve::draw (QPainter *painter, const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, const QRect &canvasRect) const\fC [virtual]\fP"

.PP
Draw the complete curve\&. \fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIxMap\fP Maps x-values into pixel coordinates\&. 
.br
\fIyMap\fP Maps y-values into pixel coordinates\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBdrawCurve()\fP, \fBdrawSymbols()\fP 
.RE
.PP

.PP
Implements \fBQwtPlotItem\fP\&.
.SS "void QwtPlotCurve::draw (QPainter *painter, const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, intfrom, intto) const\fC [virtual]\fP"

.PP
Draw an interval of the curve\&. \fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIxMap\fP maps x-values into pixel coordinates\&. 
.br
\fIyMap\fP maps y-values into pixel coordinates\&. 
.br
\fIfrom\fP index of the first point to be painted 
.br
\fIto\fP index of the last point to be painted\&. If to < 0 the curve will be painted to its last point\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBdrawCurve()\fP, \fBdrawSymbols()\fP, 
.RE
.PP

.SS "void QwtPlotCurve::draw (intfrom, intto) const"

.PP
Draw a set of points of a curve\&. When observing an measurement while it is running, new points have to be added to an existing curve\&. drawCurve can be used to display them avoiding a complete redraw of the canvas\&.
.PP
Setting \fBplot()\fP->canvas()->setAttribute(Qt::WA_PaintOutsidePaintEvent, true); will result in faster painting, if the paint engine of the canvas widget supports this feature\&.
.PP
\fBParameters:\fP
.RS 4
\fIfrom\fP Index of the first point to be painted 
.br
\fIto\fP Index of the last point to be painted\&. If to < 0 the curve will be painted to its last point\&.
.RE
.PP
\fBSee also:\fP
.RS 4
\fBdrawCurve()\fP, \fBdrawSymbols()\fP 
.RE
.PP

.SS "void QwtPlotCurve::drawCurve (QPainter *painter, intstyle, const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, intfrom, intto) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Draw the line part (without symbols) of a curve interval\&. \fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIstyle\fP curve style, see \fBQwtPlotCurve::CurveStyle\fP 
.br
\fIxMap\fP x map 
.br
\fIyMap\fP y map 
.br
\fIfrom\fP index of the first point to be painted 
.br
\fIto\fP index of the last point to be painted 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBdraw()\fP, \fBdrawDots()\fP, \fBdrawLines()\fP, \fBdrawSteps()\fP, \fBdrawSticks()\fP 
.RE
.PP

.SS "void QwtPlotCurve::drawDots (QPainter *painter, const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, intfrom, intto) const\fC [protected]\fP"
Draw dots
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIxMap\fP x map 
.br
\fIyMap\fP y map 
.br
\fIfrom\fP index of the first point to be painted 
.br
\fIto\fP index of the last point to be painted
.RE
.PP
\fBSee also:\fP
.RS 4
\fBdraw()\fP, \fBdrawCurve()\fP, \fBdrawSticks()\fP, \fBdrawLines()\fP, \fBdrawSteps()\fP 
.RE
.PP

.SS "void QwtPlotCurve::drawLines (QPainter *painter, const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, intfrom, intto) const\fC [protected]\fP"

.PP
Draw lines\&. If the CurveAttribute Fitted is enabled a \fBQwtCurveFitter\fP tries to interpolate/smooth the curve, before it is painted\&.
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIxMap\fP x map 
.br
\fIyMap\fP y map 
.br
\fIfrom\fP index of the first point to be painted 
.br
\fIto\fP index of the last point to be painted
.RE
.PP
\fBSee also:\fP
.RS 4
\fBsetCurveAttribute()\fP, \fBsetCurveFitter()\fP, \fBdraw()\fP, \fBdrawLines()\fP, \fBdrawDots()\fP, \fBdrawSteps()\fP, \fBdrawSticks()\fP 
.RE
.PP

.SS "void QwtPlotCurve::drawSteps (QPainter *painter, const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, intfrom, intto) const\fC [protected]\fP"
Draw step function
.PP
The direction of the steps depends on Inverted attribute\&.
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIxMap\fP x map 
.br
\fIyMap\fP y map 
.br
\fIfrom\fP index of the first point to be painted 
.br
\fIto\fP index of the last point to be painted
.RE
.PP
\fBSee also:\fP
.RS 4
\fBCurveAttribute\fP, \fBsetCurveAttribute()\fP, \fBdraw()\fP, \fBdrawCurve()\fP, \fBdrawDots()\fP, \fBdrawLines()\fP, \fBdrawSticks()\fP 
.RE
.PP

.SS "void QwtPlotCurve::drawSticks (QPainter *painter, const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, intfrom, intto) const\fC [protected]\fP"
Draw sticks
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIxMap\fP x map 
.br
\fIyMap\fP y map 
.br
\fIfrom\fP index of the first point to be painted 
.br
\fIto\fP index of the last point to be painted
.RE
.PP
\fBSee also:\fP
.RS 4
\fBdraw()\fP, \fBdrawCurve()\fP, \fBdrawDots()\fP, \fBdrawLines()\fP, \fBdrawSteps()\fP 
.RE
.PP

.SS "void QwtPlotCurve::drawSymbols (QPainter *painter, const \fBQwtSymbol\fP &symbol, const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, intfrom, intto) const\fC [protected]\fP, \fC [virtual]\fP"

.PP
Draw symbols\&. \fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIsymbol\fP Curve symbol 
.br
\fIxMap\fP x map 
.br
\fIyMap\fP y map 
.br
\fIfrom\fP index of the first point to be painted 
.br
\fIto\fP index of the last point to be painted
.RE
.PP
\fBSee also:\fP
.RS 4
\fBsetSymbol()\fP, \fBdraw()\fP, \fBdrawCurve()\fP 
.RE
.PP

.SS "void QwtPlotCurve::fillCurve (QPainter *painter, const \fBQwtScaleMap\fP &xMap, const \fBQwtScaleMap\fP &yMap, QwtPolygon &pa) const\fC [protected]\fP"
Fill the area between the curve and the baseline with the curve brush
.PP
\fBParameters:\fP
.RS 4
\fIpainter\fP Painter 
.br
\fIxMap\fP x map 
.br
\fIyMap\fP y map 
.br
\fIpa\fP Polygon
.RE
.PP
\fBSee also:\fP
.RS 4
\fBsetBrush()\fP, \fBsetBaseline()\fP, \fBsetCurveType()\fP 
.RE
.PP

.SS "const QPen & QwtPlotCurve::pen () const"

.PP
Return the pen used to draw the lines\&. \fBSee also:\fP
.RS 4
\fBsetPen()\fP, \fBbrush()\fP 
.RE
.PP

.SS "int QwtPlotCurve::rtti () const\fC [virtual]\fP"
\fBReturns:\fP
.RS 4
QwtPlotItem::Rtti_PlotCurve 
.RE
.PP

.PP
Reimplemented from \fBQwtPlotItem\fP\&.
.SS "void QwtPlotCurve::setBaseline (doublereference)"

.PP
Set the value of the baseline\&. The baseline is needed for filling the curve with a brush or the Sticks drawing style\&. The default value is 0\&.0\&. The interpretation of the baseline depends on the CurveType\&. With QwtPlotCurve::Yfx, the baseline is interpreted as a horizontal line at y = \fBbaseline()\fP, with QwtPlotCurve::Yfy, it is interpreted as a vertical line at x = \fBbaseline()\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIreference\fP baseline 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBbaseline()\fP, \fBsetBrush()\fP, \fBsetStyle()\fP, \fBsetCurveType()\fP 
.RE
.PP

.SS "void QwtPlotCurve::setBrush (const QBrush &brush)"

.PP
Assign a brush\&. In case of brush\&.style() != QBrush::NoBrush and \fBstyle()\fP != QwtPlotCurve::Sticks the area between the curve and the baseline will be filled\&.
.PP
In case !brush\&.color()\&.isValid() the area will be filled by pen\&.color()\&. The fill algorithm simply connects the first and the last curve point to the baseline\&. So the curve data has to be sorted (ascending or descending)\&.
.PP
\fBParameters:\fP
.RS 4
\fIbrush\fP New brush 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBbrush()\fP, \fBsetBaseline()\fP, \fBbaseline()\fP 
.RE
.PP

.SS "void QwtPlotCurve::setCurveAttribute (\fBCurveAttribute\fPattribute, boolon = \fCtrue\fP)"
Specify an attribute for drawing the curve
.PP
\fBParameters:\fP
.RS 4
\fIattribute\fP Curve attribute 
.br
\fIon\fP On/Off
.RE
.PP
/sa CurveAttribute, \fBtestCurveAttribute()\fP, \fBsetCurveFitter()\fP 
.SS "void QwtPlotCurve::setCurveFitter (\fBQwtCurveFitter\fP *curveFitter)"
Assign a curve fitter setCurveFitter(NULL) disables curve fitting\&.
.PP
\fBParameters:\fP
.RS 4
\fIcurveFitter\fP Curve fitter 
.RE
.PP

.SS "void QwtPlotCurve::setCurveType (\fBCurveType\fPcurveType)"
Assign the curve type
.PP
\fBParameters:\fP
.RS 4
\fIcurveType\fP Yfx or Xfy 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBCurveType\fP, \fBcurveType()\fP 
.RE
.PP

.SS "void QwtPlotCurve::setData (const double *xData, const double *yData, intsize)"
Set data by copying x- and y-values from specified memory blocks\&. Contrary to setCurveRawData(), this function makes a 'deep copy' of the data\&.
.PP
\fBParameters:\fP
.RS 4
\fIxData\fP Pointer to x values 
.br
\fIyData\fP Pointer to y values 
.br
\fIsize\fP Size of xData and yData
.RE
.PP
\fBNote:\fP
.RS 4
Internally the data is stored in a \fBQwtArrayData\fP object 
.RE
.PP

.SS "void QwtPlotCurve::setData (const QwtArray< double > &xData, const QwtArray< double > &yData)"
Initialize data with x- and y-arrays (explicitly shared) ( Builds an \fBQwtArrayData\fP object internally )
.PP
\fBParameters:\fP
.RS 4
\fIxData\fP x data 
.br
\fIyData\fP y data
.RE
.PP
\fBNote:\fP
.RS 4
Internally the data is stored in a \fBQwtArrayData\fP object 
.RE
.PP

.SS "void QwtPlotCurve::setData (const QPolygonF &data)"
Initialize data with an array of points (explicitly shared)\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP Data 
.RE
.PP
\fBNote:\fP
.RS 4
Internally the data is stored in a \fBQwtPolygonFData\fP object 
.RE
.PP

.SS "void QwtPlotCurve::setData (const \fBQwtData\fP &data)"
Initialize data with a pointer to \fBQwtData\fP\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP Data 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBQwtData::copy()\fP 
.RE
.PP

.SS "void QwtPlotCurve::setPaintAttribute (\fBPaintAttribute\fPattribute, boolon = \fCtrue\fP)"
Specify an attribute how to draw the curve
.PP
\fBParameters:\fP
.RS 4
\fIattribute\fP Paint attribute 
.br
\fIon\fP On/Off /sa PaintAttribute, \fBtestPaintAttribute()\fP 
.RE
.PP

.SS "void QwtPlotCurve::setPen (const QPen &pen)"
Assign a pen
.PP
The width of non cosmetic pens is scaled according to the resolution of the paint device\&.
.PP
\fBParameters:\fP
.RS 4
\fIpen\fP New pen 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBpen()\fP, \fBbrush()\fP, \fBQwtPainter::scaledPen()\fP 
.RE
.PP

.SS "void QwtPlotCurve::setRawData (const double *xData, const double *yData, intsize)"

.PP
Initialize the data by pointing to memory blocks which are not managed by \fBQwtPlotCurve\fP\&. setRawData is provided for efficiency\&. It is important to keep the pointers during the lifetime of the underlying \fBQwtCPointerData\fP class\&.
.PP
\fBParameters:\fP
.RS 4
\fIxData\fP pointer to x data 
.br
\fIyData\fP pointer to y data 
.br
\fIsize\fP size of x and y
.RE
.PP
\fBNote:\fP
.RS 4
Internally the data is stored in a \fBQwtCPointerData\fP object 
.RE
.PP

.SS "void QwtPlotCurve::setStyle (\fBCurveStyle\fPstyle)"
Set the curve's drawing style
.PP
\fBParameters:\fP
.RS 4
\fIstyle\fP Curve style 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBCurveStyle\fP, \fBstyle()\fP 
.RE
.PP

.SS "void QwtPlotCurve::setSymbol (const \fBQwtSymbol\fP &symbol)"

.PP
Assign a symbol\&. \fBParameters:\fP
.RS 4
\fIsymbol\fP Symbol 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBsymbol()\fP 
.RE
.PP

.SS "\fBQwtPlotCurve::CurveStyle\fP QwtPlotCurve::style () const"
Return the current style 
.PP
\fBSee also:\fP
.RS 4
\fBCurveStyle\fP, \fBsetStyle()\fP 
.RE
.PP

.SS "const \fBQwtSymbol\fP & QwtPlotCurve::symbol () const"

.PP
Return the current symbol\&. \fBSee also:\fP
.RS 4
\fBsetSymbol()\fP 
.RE
.PP

.SS "bool QwtPlotCurve::testCurveAttribute (\fBCurveAttribute\fPattribute) const"
\fBReturns:\fP
.RS 4
true, if attribute is enabled 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBCurveAttribute\fP, \fBsetCurveAttribute()\fP 
.RE
.PP

.SS "bool QwtPlotCurve::testPaintAttribute (\fBPaintAttribute\fPattribute) const"

.PP
Return the current paint attributes\&. \fBSee also:\fP
.RS 4
\fBPaintAttribute\fP, \fBsetPaintAttribute()\fP 
.RE
.PP

.SS "double QwtPlotCurve::x (inti) const\fC [inline]\fP"
\fBParameters:\fP
.RS 4
\fIi\fP index 
.RE
.PP
\fBReturns:\fP
.RS 4
x-value at position i 
.RE
.PP

.SS "double QwtPlotCurve::y (inti) const\fC [inline]\fP"
\fBParameters:\fP
.RS 4
\fIi\fP index 
.RE
.PP
\fBReturns:\fP
.RS 4
y-value at position i 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for Qwt User's Guide from the source code\&.
